var background=function(){"use strict";function e(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var t,r={exports:{}};function s(){return t||(t=1,"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self&&self,function(e){if(!(globalThis.chrome&&globalThis.chrome.runtime&&globalThis.chrome.runtime.id))throw new Error("This script should only be loaded in a browser extension.");if(globalThis.browser&&globalThis.browser.runtime&&globalThis.browser.runtime.id)e.exports=globalThis.browser;else{const t="The message port closed before a response was received.",r=e=>{const r={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(0===Object.keys(r).length)throw new Error("api-metadata.json has not been included in browser-polyfill");class s extends WeakMap{constructor(e,t=void 0){super(t),this.createItem=e}get(e){return this.has(e)||this.set(e,this.createItem(e)),super.get(e)}}const a=e=>e&&"object"==typeof e&&"function"==typeof e.then,n=(t,r)=>(...s)=>{e.runtime.lastError?t.reject(new Error(e.runtime.lastError.message)):r.singleCallbackArg||s.length<=1&&!1!==r.singleCallbackArg?t.resolve(s[0]):t.resolve(s)},o=e=>1==e?"argument":"arguments",i=(e,t)=>function(r,...s){if(s.length<t.minArgs)throw new Error(`Expected at least ${t.minArgs} ${o(t.minArgs)} for ${e}(), got ${s.length}`);if(s.length>t.maxArgs)throw new Error(`Expected at most ${t.maxArgs} ${o(t.maxArgs)} for ${e}(), got ${s.length}`);return new Promise((a,o)=>{if(t.fallbackToNoCallback)try{r[e](...s,n({resolve:a,reject:o},t))}catch(i){r[e](...s),t.fallbackToNoCallback=!1,t.noCallback=!0,a()}else t.noCallback?(r[e](...s),a()):r[e](...s,n({resolve:a,reject:o},t))})},c=(e,t,r)=>new Proxy(t,{apply:(t,s,a)=>r.call(s,e,...a)});let l=Function.call.bind(Object.prototype.hasOwnProperty);const u=(e,t={},r={})=>{let s=Object.create(null),a={has:(t,r)=>r in e||r in s,get(a,n,o){if(n in s)return s[n];if(!(n in e))return;let h=e[n];if("function"==typeof h)if("function"==typeof t[n])h=c(e,e[n],t[n]);else if(l(r,n)){let t=i(n,r[n]);h=c(e,e[n],t)}else h=h.bind(e);else if("object"==typeof h&&null!==h&&(l(t,n)||l(r,n)))h=u(h,t[n],r[n]);else{if(!l(r,"*"))return Object.defineProperty(s,n,{configurable:!0,enumerable:!0,get:()=>e[n],set(t){e[n]=t}}),h;h=u(h,t[n],r["*"])}return s[n]=h,h},set:(t,r,a,n)=>(r in s?s[r]=a:e[r]=a,!0),defineProperty:(e,t,r)=>Reflect.defineProperty(s,t,r),deleteProperty:(e,t)=>Reflect.deleteProperty(s,t)},n=Object.create(e);return new Proxy(n,a)},h=e=>({addListener(t,r,...s){t.addListener(e.get(r),...s)},hasListener:(t,r)=>t.hasListener(e.get(r)),removeListener(t,r){t.removeListener(e.get(r))}}),g=new s(e=>"function"!=typeof e?e:function(t){const r=u(t,{},{getContent:{minArgs:0,maxArgs:0}});e(r)}),m=new s(e=>"function"!=typeof e?e:function(t,r,s){let n,o,i=!1,c=new Promise(e=>{n=function(t){i=!0,e(t)}});try{o=e(t,r,n)}catch(h){o=Promise.reject(h)}const l=!0!==o&&a(o);if(!0!==o&&!l&&!i)return!1;const u=e=>{e.then(e=>{s(e)},e=>{let t;t=e&&(e instanceof Error||"string"==typeof e.message)?e.message:"An unexpected error occurred",s({__mozWebExtensionPolyfillReject__:!0,message:t})}).catch(e=>{})};return u(l?o:c),!0}),d=({reject:r,resolve:s},a)=>{e.runtime.lastError?e.runtime.lastError.message===t?s():r(new Error(e.runtime.lastError.message)):a&&a.__mozWebExtensionPolyfillReject__?r(new Error(a.message)):s(a)},p=(e,t,r,...s)=>{if(s.length<t.minArgs)throw new Error(`Expected at least ${t.minArgs} ${o(t.minArgs)} for ${e}(), got ${s.length}`);if(s.length>t.maxArgs)throw new Error(`Expected at most ${t.maxArgs} ${o(t.maxArgs)} for ${e}(), got ${s.length}`);return new Promise((e,t)=>{const a=d.bind(null,{resolve:e,reject:t});s.push(a),r.sendMessage(...s)})},f={devtools:{network:{onRequestFinished:h(g)}},runtime:{onMessage:h(m),onMessageExternal:h(m),sendMessage:p.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:p.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},w={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return r.privacy={network:{"*":w},services:{"*":w},websites:{"*":w}},u(e,f,r)};e.exports=r(chrome)}}(r)),r.exports}const a=e(s()),n={"invalid-value":({paramName:e,validValueDescription:t,value:r})=>{if(!e||!t)throw new Error("Unexpected input to 'invalid-value' error.");return`The '${e}' parameter was given a value with an unexpected value. ${t} Received a value of ${JSON.stringify(r)}.`},"not-an-array":({moduleName:e,className:t,funcName:r,paramName:s})=>{if(!(e&&t&&r&&s))throw new Error("Unexpected input to 'not-an-array' error.");return`The parameter '${s}' passed into '${e}.${t}.${r}()' must be an array.`},"incorrect-type":({expectedType:e,paramName:t,moduleName:r,className:s,funcName:a})=>{if(!(e&&t&&r&&a))throw new Error("Unexpected input to 'incorrect-type' error.");return`The parameter '${t}' passed into '${r}.${s?`${s}.`:""}${a}()' must be of type ${e}.`},"incorrect-class":({expectedClassName:e,paramName:t,moduleName:r,className:s,funcName:a,isReturnValueProblem:n})=>{if(!e||!r||!a)throw new Error("Unexpected input to 'incorrect-class' error.");const o=s?`${s}.`:"";return n?`The return value from '${r}.${o}${a}()' must be an instance of class ${e}.`:`The parameter '${t}' passed into '${r}.${o}${a}()' must be an instance of class ${e}.`},"missing-a-method":({expectedMethod:e,paramName:t,moduleName:r,className:s,funcName:a})=>{if(!(e&&t&&r&&s&&a))throw new Error("Unexpected input to 'missing-a-method' error.");return`${r}.${s}.${a}() expected the '${t}' parameter to expose a '${e}' method.`},"add-to-cache-list-unexpected-type":({entry:e})=>`An unexpected entry was passed to 'workbox-precaching.PrecacheController.addToCacheList()' The entry '${JSON.stringify(e)}' isn't supported. You must supply an array of strings with one or more characters, objects with a url property or Request objects.`,"add-to-cache-list-conflicting-entries":({firstEntry:e,secondEntry:t})=>{if(!e||!t)throw new Error("Unexpected input to 'add-to-cache-list-duplicate-entries' error.");return`Two of the entries passed to 'workbox-precaching.PrecacheController.addToCacheList()' had the URL ${e} but different revision details. Workbox is unable to cache and version the asset correctly. Please remove one of the entries.`},"plugin-error-request-will-fetch":({thrownErrorMessage:e})=>{if(!e)throw new Error("Unexpected input to 'plugin-error-request-will-fetch', error.");return`An error was thrown by a plugins 'requestWillFetch()' method. The thrown error message was: '${e}'.`},"invalid-cache-name":({cacheNameId:e,value:t})=>{if(!e)throw new Error("Expected a 'cacheNameId' for error 'invalid-cache-name'");return`You must provide a name containing at least one character for setCacheDetails({${e}: '...'}). Received a value of '${JSON.stringify(t)}'`},"unregister-route-but-not-found-with-method":({method:e})=>{if(!e)throw new Error("Unexpected input to 'unregister-route-but-not-found-with-method' error.");return`The route you're trying to unregister was not  previously registered for the method type '${e}'.`},"unregister-route-route-not-registered":()=>"The route you're trying to unregister was not previously registered.","queue-replay-failed":({name:e})=>`Replaying the background sync queue '${e}' failed.`,"duplicate-queue-name":({name:e})=>`The Queue name '${e}' is already being used. All instances of backgroundSync.Queue must be given unique names.`,"expired-test-without-max-age":({methodName:e,paramName:t})=>`The '${e}()' method can only be used when the '${t}' is used in the constructor.`,"unsupported-route-type":({moduleName:e,className:t,funcName:r,paramName:s})=>`The supplied '${s}' parameter was an unsupported type. Please check the docs for ${e}.${t}.${r} for valid input types.`,"not-array-of-class":({value:e,expectedClass:t,moduleName:r,className:s,funcName:a,paramName:n})=>`The supplied '${n}' parameter must be an array of '${t}' objects. Received '${JSON.stringify(e)},'. Please check the call to ${r}.${s}.${a}() to fix the issue.`,"max-entries-or-age-required":({moduleName:e,className:t,funcName:r})=>`You must define either config.maxEntries or config.maxAgeSecondsin ${e}.${t}.${r}`,"statuses-or-headers-required":({moduleName:e,className:t,funcName:r})=>`You must define either config.statuses or config.headersin ${e}.${t}.${r}`,"invalid-string":({moduleName:e,funcName:t,paramName:r})=>{if(!r||!e||!t)throw new Error("Unexpected input to 'invalid-string' error.");return`When using strings, the '${r}' parameter must start with 'http' (for cross-origin matches) or '/' (for same-origin matches). Please see the docs for ${e}.${t}() for more info.`},"channel-name-required":()=>"You must provide a channelName to construct a BroadcastCacheUpdate instance.","invalid-responses-are-same-args":()=>"The arguments passed into responsesAreSame() appear to be invalid. Please ensure valid Responses are used.","expire-custom-caches-only":()=>"You must provide a 'cacheName' property when using the expiration plugin with a runtime caching strategy.","unit-must-be-bytes":({normalizedRangeHeader:e})=>{if(!e)throw new Error("Unexpected input to 'unit-must-be-bytes' error.");return`The 'unit' portion of the Range header must be set to 'bytes'. The Range header provided was "${e}"`},"single-range-only":({normalizedRangeHeader:e})=>{if(!e)throw new Error("Unexpected input to 'single-range-only' error.");return`Multiple ranges are not supported. Please use a  single start value, and optional end value. The Range header provided was "${e}"`},"invalid-range-values":({normalizedRangeHeader:e})=>{if(!e)throw new Error("Unexpected input to 'invalid-range-values' error.");return`The Range header is missing both start and end values. At least one of those values is needed. The Range header provided was "${e}"`},"no-range-header":()=>"No Range header was found in the Request provided.","range-not-satisfiable":({size:e,start:t,end:r})=>`The start (${t}) and end (${r}) values in the Range are not satisfiable by the cached response, which is ${e} bytes.`,"attempt-to-cache-non-get-request":({url:e,method:t})=>`Unable to cache '${e}' because it is a '${t}' request and only 'GET' requests can be cached.`,"cache-put-with-no-response":({url:e})=>`There was an attempt to cache '${e}' but the response was not defined.`,"no-response":({url:e,error:t})=>{let r=`The strategy could not generate a response for '${e}'.`;return t&&(r+=` The underlying error is ${t}.`),r},"bad-precaching-response":({url:e,status:t})=>`The precaching request for '${e}' failed`+(t?` with an HTTP status of ${t}.`:"."),"non-precached-url":({url:e})=>`createHandlerBoundToURL('${e}') was called, but that URL is not precached. Please pass in a URL that is precached instead.`,"add-to-cache-list-conflicting-integrities":({url:e})=>`Two of the entries passed to 'workbox-precaching.PrecacheController.addToCacheList()' had the URL ${e} with different integrity values. Please remove one of them.`,"missing-precache-entry":({cacheName:e,url:t})=>`Unable to find a precached response in ${e} for ${t}.`,"cross-origin-copy-response":({origin:e})=>`workbox-core.copyResponse() can only be used with same-origin responses. It was passed a response with origin ${e}.`,"opaque-streams-source":({type:e})=>{const t=`One of the workbox-streams sources resulted in an '${e}' response.`;return"opaqueredirect"===e?`${t} Please do not use a navigation request that results in a redirect as a source.`:`${t} Please ensure your sources are CORS-enabled.`}},o=(e,t={})=>{const r=n[e];if(!r)throw new Error(`Unable to find message for code '${e}'.`);return r(t)};class i extends Error{constructor(e,t){super(o(e,t)),this.name=e,this.details=t}}const c=(e,t,r)=>{if("function"!==typeof e[t])throw r.expectedMethod=t,new i("missing-a-method",r)},l=(e,t)=>{if(!Array.isArray(e))throw new i("not-an-array",t)},u=(e,t,r)=>{if(!(e instanceof t))throw r.expectedClassName=t.name,new i("incorrect-class",r)},h=(e,t,r)=>{if(!t.includes(e))throw r.validValueDescription=`Valid values are ${JSON.stringify(t)}.`,new i("invalid-value",r)},g=(e,t,r)=>{if(typeof e!==t)throw r.expectedType=t,new i("incorrect-type",r)},m=e=>new URL(String(e),location.href).href.replace(new RegExp(`^${location.origin}`),""),d=(()=>{"__WB_DISABLE_DEV_LOGS"in globalThis||(self.__WB_DISABLE_DEV_LOGS=!1);let e=!1;const t={debug:"#7f8c8d",log:"#2ecc71",warn:"#f39c12",error:"#c0392b",groupCollapsed:"#3498db",groupEnd:null},r=function(r,s){if(self.__WB_DISABLE_DEV_LOGS)return;if("groupCollapsed"===r&&/^((?!chrome|android).)*safari/i.test(navigator.userAgent))return;e||[`background: ${t[r]}`,"border-radius: 0.5em","color: white","font-weight: bold","padding: 2px 0.5em"].join(";");"groupCollapsed"===r&&(e=!0),"groupEnd"===r&&(e=!1)},s={},a=Object.keys(t);for(const n of a){const e=n;s[e]=(...t)=>{r(e)}}return s})(),p={googleAnalytics:"googleAnalytics",precache:"precache-v2",prefix:"workbox",runtime:"runtime",suffix:"undefined"!=typeof registration?registration.scope:""},f=e=>[p.prefix,e,p.suffix].filter(e=>e&&e.length>0).join("-"),w=e=>e||f(p.precache),y=e=>e||f(p.runtime),A=new Set;function v(e,t){const r=t();return e.waitUntil(r),r}function x(e){if(!e)throw new i("add-to-cache-list-unexpected-type",{entry:e});if("string"==typeof e){const t=new URL(e,location.href);return{cacheKey:t.href,url:t.href}}const{revision:t,url:r}=e;if(!r)throw new i("add-to-cache-list-unexpected-type",{entry:e});if(!t){const e=new URL(r,location.href);return{cacheKey:e.href,url:e.href}}const s=new URL(r,location.href),a=new URL(r,location.href);return s.searchParams.set("__WB_REVISION__",t),{cacheKey:s.href,url:a.href}}class b{constructor(){this.updatedURLs=[],this.notUpdatedURLs=[],this.handlerWillStart=async({request:e,state:t})=>{t&&(t.originalRequest=e)},this.cachedResponseWillBeUsed=async({event:e,state:t,cachedResponse:r})=>{if("install"===e.type&&t&&t.originalRequest&&t.originalRequest instanceof Request){const e=t.originalRequest.url;r?this.notUpdatedURLs.push(e):this.updatedURLs.push(e)}return r}}}class _{constructor({precacheController:e}){this.cacheKeyWillBeUsed=async({request:e,params:t})=>{const r=(null==t?void 0:t.cacheKey)||this._precacheController.getCacheKeyForURL(e.url);return r?new Request(r,{headers:e.headers}):e},this._precacheController=e}}function k(e){const t=e.length;t>0&&(d.groupCollapsed(`During precaching cleanup, ${t} cached request${1===t?" was":"s were"} deleted.`),((e,t)=>{d.groupCollapsed(e);for(const r of t)d.log(r);d.groupEnd()})("Deleted Cache Requests",e),d.groupEnd())}function R(e,t){if(0!==t.length){d.groupCollapsed(e);for(const e of t)d.log(e);d.groupEnd()}}let $,C;async function E(e,t){let r=null;if(e.url){r=new URL(e.url).origin}if(r!==self.location.origin)throw new i("cross-origin-copy-response",{origin:r});const s=e.clone(),a={headers:new Headers(s.headers),status:s.status,statusText:s.statusText},n=function(){if(void 0===$){const t=new Response("");if("body"in t)try{new Response(t.body),$=!0}catch(e){$=!1}$=!1}return $}()?s.body:await s.blob();return new Response(n,a)}function N(e,t){const r=new URL(e);for(const s of t)r.searchParams.delete(s);return r.href}class T{constructor(){this.promise=new Promise((e,t)=>{this.resolve=e,this.reject=t})}}function U(e){return"string"==typeof e?new Request(e):e}class L{constructor(e,t){this._cacheKeys={},u(t.event,ExtendableEvent,{moduleName:"workbox-strategies",className:"StrategyHandler",funcName:"constructor",paramName:"options.event"}),Object.assign(this,t),this.event=t.event,this._strategy=e,this._handlerDeferred=new T,this._extendLifetimePromises=[],this._plugins=[...e.plugins],this._pluginStateMap=new Map;for(const r of this._plugins)this._pluginStateMap.set(r,{});this.event.waitUntil(this._handlerDeferred.promise)}async fetch(e){const{event:t}=this;let r=U(e);if("navigate"===r.mode&&t instanceof FetchEvent&&t.preloadResponse){const e=await t.preloadResponse;if(e)return d.log(`Using a preloaded navigation response for '${m(r.url)}'`),e}const s=this.hasCallback("fetchDidFail")?r.clone():null;try{for(const e of this.iterateCallbacks("requestWillFetch"))r=await e({request:r.clone(),event:t})}catch(n){if(n instanceof Error)throw new i("plugin-error-request-will-fetch",{thrownErrorMessage:n.message})}const a=r.clone();try{let e;e=await fetch(r,"navigate"===r.mode?void 0:this._strategy.fetchOptions),d.debug(`Network request for '${m(r.url)}' returned a response with status '${e.status}'.`);for(const r of this.iterateCallbacks("fetchDidSucceed"))e=await r({event:t,request:a,response:e});return e}catch(o){throw d.log(`Network request for '${m(r.url)}' threw an error.`,o),s&&await this.runCallbacks("fetchDidFail",{error:o,event:t,originalRequest:s.clone(),request:a.clone()}),o}}async fetchAndCachePut(e){const t=await this.fetch(e),r=t.clone();return this.waitUntil(this.cachePut(e,r)),t}async cacheMatch(e){const t=U(e);let r;const{cacheName:s,matchOptions:a}=this._strategy,n=await this.getCacheKey(t,"read"),o=Object.assign(Object.assign({},a),{cacheName:s});r=await caches.match(n,o),r?d.debug(`Found a cached response in '${s}'.`):d.debug(`No cached response found in '${s}'.`);for(const i of this.iterateCallbacks("cachedResponseWillBeUsed"))r=await i({cacheName:s,matchOptions:a,cachedResponse:r,request:n,event:this.event})||void 0;return r}async cachePut(e,t){const r=U(e);var s;await(s=0,new Promise(e=>setTimeout(e,s)));const a=await this.getCacheKey(r,"write");{if(a.method&&"GET"!==a.method)throw new i("attempt-to-cache-non-get-request",{url:m(a.url),method:a.method});const e=t.headers.get("Vary");e&&d.debug(`The response for ${m(a.url)} has a 'Vary: ${e}' header. Consider setting the {ignoreVary: true} option on your strategy to ensure cache matching and deletion works as expected.`)}if(!t)throw d.error(`Cannot cache non-existent response for '${m(a.url)}'.`),new i("cache-put-with-no-response",{url:m(a.url)});const n=await this._ensureResponseSafeToCache(t);if(!n)return d.debug(`Response '${m(a.url)}' will not be cached.`,n),!1;const{cacheName:o,matchOptions:c}=this._strategy,l=await self.caches.open(o),u=this.hasCallback("cacheDidUpdate"),h=u?await async function(e,t,r,s){const a=N(t.url,r);if(t.url===a)return e.match(t,s);const n=Object.assign(Object.assign({},s),{ignoreSearch:!0}),o=await e.keys(t,n);for(const i of o)if(a===N(i.url,r))return e.match(i,s)}(l,a.clone(),["__WB_REVISION__"],c):null;d.debug(`Updating the '${o}' cache with a new Response for ${m(a.url)}.`);try{await l.put(a,u?n.clone():n)}catch(g){if(g instanceof Error)throw"QuotaExceededError"===g.name&&await async function(){d.log(`About to run ${A.size} callbacks to clean up caches.`);for(const e of A)await e(),d.log(e,"is complete.");d.log("Finished running callbacks.")}(),g}for(const i of this.iterateCallbacks("cacheDidUpdate"))await i({cacheName:o,oldResponse:h,newResponse:n.clone(),request:a,event:this.event});return!0}async getCacheKey(e,t){const r=`${e.url} | ${t}`;if(!this._cacheKeys[r]){let s=e;for(const e of this.iterateCallbacks("cacheKeyWillBeUsed"))s=U(await e({mode:t,request:s,event:this.event,params:this.params}));this._cacheKeys[r]=s}return this._cacheKeys[r]}hasCallback(e){for(const t of this._strategy.plugins)if(e in t)return!0;return!1}async runCallbacks(e,t){for(const r of this.iterateCallbacks(e))await r(t)}*iterateCallbacks(e){for(const t of this._strategy.plugins)if("function"==typeof t[e]){const r=this._pluginStateMap.get(t),s=s=>{const a=Object.assign(Object.assign({},s),{state:r});return t[e](a)};yield s}}waitUntil(e){return this._extendLifetimePromises.push(e),e}async doneWaiting(){let e;for(;e=this._extendLifetimePromises.shift();)await e}destroy(){this._handlerDeferred.resolve(null)}async _ensureResponseSafeToCache(e){let t=e,r=!1;for(const s of this.iterateCallbacks("cacheWillUpdate"))if(t=await s({request:this.request,response:t,event:this.event})||void 0,r=!0,!t)break;return r||(t&&200!==t.status&&(t=void 0),t&&200!==t.status&&(0===t.status?d.warn(`The response for '${this.request.url}' is an opaque response. The caching strategy that you're using will not cache opaque responses by default.`):d.debug(`The response for '${this.request.url}' returned a status code of '${e.status}' and won't be cached as a result.`))),t}}class q{constructor(e={}){this.cacheName=y(e.cacheName),this.plugins=e.plugins||[],this.fetchOptions=e.fetchOptions,this.matchOptions=e.matchOptions}handle(e){const[t]=this.handleAll(e);return t}handleAll(e){e instanceof FetchEvent&&(e={event:e,request:e.request});const t=e.event,r="string"==typeof e.request?new Request(e.request):e.request,s="params"in e?e.params:void 0,a=new L(this,{event:t,request:r,params:s}),n=this._getResponse(a,r,t);return[n,this._awaitComplete(n,a,r,t)]}async _getResponse(e,t,r){let s;await e.runCallbacks("handlerWillStart",{event:r,request:t});try{if(s=await this._handle(t,e),!s||"error"===s.type)throw new i("no-response",{url:t.url})}catch(a){if(a instanceof Error)for(const n of e.iterateCallbacks("handlerDidError"))if(s=await n({error:a,event:r,request:t}),s)break;if(!s)throw a;d.log(`While responding to '${m(t.url)}', an ${a instanceof Error?a.toString():""} error occurred. Using a fallback response provided by a handlerDidError plugin.`)}for(const n of e.iterateCallbacks("handlerWillRespond"))s=await n({event:r,request:t,response:s});return s}async _awaitComplete(e,t,r,s){let a,n;try{a=await e}catch(o){}try{await t.runCallbacks("handlerDidRespond",{event:s,request:r,response:a}),await t.doneWaiting()}catch(i){i instanceof Error&&(n=i)}if(await t.runCallbacks("handlerDidComplete",{event:s,request:r,response:a,error:n}),t.destroy(),n)throw n}}class P extends q{constructor(e={}){e.cacheName=w(e.cacheName),super(e),this._fallbackToNetwork=!1!==e.fallbackToNetwork,this.plugins.push(P.copyRedirectedCacheableResponsesPlugin)}async _handle(e,t){const r=await t.cacheMatch(e);return r||(t.event&&"install"===t.event.type?await this._handleInstall(e,t):await this._handleFetch(e,t))}async _handleFetch(e,t){let r;const s=t.params||{};if(!this._fallbackToNetwork)throw new i("missing-precache-entry",{cacheName:this.cacheName,url:e.url});{d.warn(`The precached response for ${m(e.url)} in ${this.cacheName} was not found. Falling back to the network.`);const a=s.integrity,n=e.integrity,o=!n||n===a;if(r=await t.fetch(new Request(e,{integrity:"no-cors"!==e.mode?n||a:void 0})),a&&o&&"no-cors"!==e.mode){this._useDefaultCacheabilityPluginIfNeeded();await t.cachePut(e,r.clone())&&d.log(`A response for ${m(e.url)} was used to "repair" the precache.`)}}{const a=s.cacheKey||await t.getCacheKey(e,"read");d.groupCollapsed("Precaching is responding to: "+m(e.url)),d.log(`Serving the precached url: ${m(a instanceof Request?a.url:a)}`),d.groupCollapsed("View request details here."),d.log(e),d.groupEnd(),d.groupCollapsed("View response details here."),d.log(r),d.groupEnd(),d.groupEnd()}return r}async _handleInstall(e,t){this._useDefaultCacheabilityPluginIfNeeded();const r=await t.fetch(e);if(!(await t.cachePut(e,r.clone())))throw new i("bad-precaching-response",{url:e.url,status:r.status});return r}_useDefaultCacheabilityPluginIfNeeded(){let e=null,t=0;for(const[r,s]of this.plugins.entries())s!==P.copyRedirectedCacheableResponsesPlugin&&(s===P.defaultPrecacheCacheabilityPlugin&&(e=r),s.cacheWillUpdate&&t++);0===t?this.plugins.push(P.defaultPrecacheCacheabilityPlugin):t>1&&null!==e&&this.plugins.splice(e,1)}}P.defaultPrecacheCacheabilityPlugin={cacheWillUpdate:async({response:e})=>!e||e.status>=400?null:e},P.copyRedirectedCacheableResponsesPlugin={cacheWillUpdate:async({response:e})=>e.redirected?await E(e):e};class I{constructor({cacheName:e,plugins:t=[],fallbackToNetwork:r=!0}={}){this._urlsToCacheKeys=new Map,this._urlsToCacheModes=new Map,this._cacheKeysToIntegrities=new Map,this._strategy=new P({cacheName:w(e),plugins:[...t,new _({precacheController:this})],fallbackToNetwork:r}),this.install=this.install.bind(this),this.activate=this.activate.bind(this)}get strategy(){return this._strategy}precache(e){this.addToCacheList(e),this._installAndActiveListenersAdded||(self.addEventListener("install",this.install),self.addEventListener("activate",this.activate),this._installAndActiveListenersAdded=!0)}addToCacheList(e){l(e,{moduleName:"workbox-precaching",className:"PrecacheController",funcName:"addToCacheList",paramName:"entries"});const t=[];for(const r of e){"string"==typeof r?t.push(r):r&&void 0===r.revision&&t.push(r.url);const{cacheKey:e,url:s}=x(r),a="string"!=typeof r&&r.revision?"reload":"default";if(this._urlsToCacheKeys.has(s)&&this._urlsToCacheKeys.get(s)!==e)throw new i("add-to-cache-list-conflicting-entries",{firstEntry:this._urlsToCacheKeys.get(s),secondEntry:e});if("string"!=typeof r&&r.integrity){if(this._cacheKeysToIntegrities.has(e)&&this._cacheKeysToIntegrities.get(e)!==r.integrity)throw new i("add-to-cache-list-conflicting-integrities",{url:s});this._cacheKeysToIntegrities.set(e,r.integrity)}if(this._urlsToCacheKeys.set(s,e),this._urlsToCacheModes.set(s,a),t.length>0){const e=`Workbox is precaching URLs without revision info: ${t.join(", ")}\nThis is generally NOT safe. Learn more at https://bit.ly/wb-precache`;d.warn(e)}}}install(e){return v(e,async()=>{const t=new b;this.strategy.plugins.push(t);for(const[a,n]of this._urlsToCacheKeys){const t=this._cacheKeysToIntegrities.get(n),r=this._urlsToCacheModes.get(a),s=new Request(a,{integrity:t,cache:r,credentials:"same-origin"});await Promise.all(this.strategy.handleAll({params:{cacheKey:n},request:s,event:e}))}const{updatedURLs:r,notUpdatedURLs:s}=t;return function(e,t){const r=e.length,s=t.length;if(r||s){let a=`Precaching ${r} file${1===r?"":"s"}.`;s>0&&(a+=` ${s} file${1===s?" is":"s are"} already cached.`),d.groupCollapsed(a),R("View newly precached URLs.",e),R("View previously precached URLs.",t),d.groupEnd()}}(r,s),{updatedURLs:r,notUpdatedURLs:s}})}activate(e){return v(e,async()=>{const e=await self.caches.open(this.strategy.cacheName),t=await e.keys(),r=new Set(this._urlsToCacheKeys.values()),s=[];for(const a of t)r.has(a.url)||(await e.delete(a),s.push(a.url));return k(s),{deletedURLs:s}})}getURLsToCacheKeys(){return this._urlsToCacheKeys}getCachedURLs(){return[...this._urlsToCacheKeys.keys()]}getCacheKeyForURL(e){const t=new URL(e,location.href);return this._urlsToCacheKeys.get(t.href)}getIntegrityForCacheKey(e){return this._cacheKeysToIntegrities.get(e)}async matchPrecache(e){const t=e instanceof Request?e.url:e,r=this.getCacheKeyForURL(t);if(r){return(await self.caches.open(this.strategy.cacheName)).match(r)}}createHandlerBoundToURL(e){const t=this.getCacheKeyForURL(e);if(!t)throw new i("non-precached-url",{url:e});return r=>(r.request=new Request(e),r.params=Object.assign({cacheKey:t},r.params),this.strategy.handle(r))}}const S=()=>(C||(C=new I),C),M=["DELETE","GET","HEAD","PATCH","POST","PUT"],O=e=>e&&"object"==typeof e?(c(e,"handle",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"handler"}),e):(g(e,"function",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"handler"}),{handle:e});class K{constructor(e,t,r="GET"){g(e,"function",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"match"}),r&&h(r,M,{paramName:"method"}),this.handler=O(t),this.match=e,this.method=r}setCatchHandler(e){this.catchHandler=O(e)}}class j extends K{constructor(e,t,r){u(e,RegExp,{moduleName:"workbox-routing",className:"RegExpRoute",funcName:"constructor",paramName:"pattern"});super(({url:t})=>{const r=e.exec(t.href);if(r){if(t.origin===location.origin||0===r.index)return r.slice(1);d.debug(`The regular expression '${e.toString()}' only partially matched against the cross-origin URL '${t.toString()}'. RegExpRoute's will only handle cross-origin requests if they match the entire URL.`)}},t,r)}}class W{constructor(){this._routes=new Map,this._defaultHandlerMap=new Map}get routes(){return this._routes}addFetchListener(){self.addEventListener("fetch",e=>{const{request:t}=e,r=this.handleRequest({request:t,event:e});r&&e.respondWith(r)})}addCacheListener(){self.addEventListener("message",e=>{if(e.data&&"CACHE_URLS"===e.data.type){const{payload:t}=e.data;d.debug("Caching URLs from the window",t.urlsToCache);const r=Promise.all(t.urlsToCache.map(t=>{"string"==typeof t&&(t=[t]);const r=new Request(...t);return this.handleRequest({request:r,event:e})}));e.waitUntil(r),e.ports&&e.ports[0]&&r.then(()=>e.ports[0].postMessage(!0))}})}handleRequest({request:e,event:t}){u(e,Request,{moduleName:"workbox-routing",className:"Router",funcName:"handleRequest",paramName:"options.request"});const r=new URL(e.url,location.href);if(!r.protocol.startsWith("http"))return void d.debug("Workbox Router only supports URLs that start with 'http'.");const s=r.origin===location.origin,{params:a,route:n}=this.findMatchingRoute({event:t,request:e,sameOrigin:s,url:r});let o=n&&n.handler;const i=[];o&&(i.push(["Found a route to handle this request:",n]),a&&i.push(["Passing the following params to the route's handler:",a]));const c=e.method;if(!o&&this._defaultHandlerMap.has(c)&&(i.push(`Failed to find a matching route. Falling back to the default handler for ${c}.`),o=this._defaultHandlerMap.get(c)),!o)return void d.debug(`No route found for: ${m(r)}`);let l;d.groupCollapsed(`Router is responding to: ${m(r)}`),i.forEach(e=>{Array.isArray(e)?d.log(...e):d.log(e)}),d.groupEnd();try{l=o.handle({url:r,request:e,event:t,params:a})}catch(g){l=Promise.reject(g)}const h=n&&n.catchHandler;return l instanceof Promise&&(this._catchHandler||h)&&(l=l.catch(async s=>{if(h){d.groupCollapsed(`Error thrown when responding to:  ${m(r)}. Falling back to route's Catch Handler.`),d.error("Error thrown by:",n),d.error(s),d.groupEnd();try{return await h.handle({url:r,request:e,event:t,params:a})}catch(o){o instanceof Error&&(s=o)}}if(this._catchHandler)return d.groupCollapsed(`Error thrown when responding to:  ${m(r)}. Falling back to global Catch Handler.`),d.error("Error thrown by:",n),d.error(s),d.groupEnd(),this._catchHandler.handle({url:r,request:e,event:t});throw s})),l}findMatchingRoute({url:e,sameOrigin:t,request:r,event:s}){const a=this._routes.get(r.method)||[];for(const n of a){let a;const o=n.match({url:e,sameOrigin:t,request:r,event:s});if(o)return o instanceof Promise&&d.warn(`While routing ${m(e)}, an async matchCallback function was used. Please convert the following route to use a synchronous matchCallback function:`,n),a=o,(Array.isArray(a)&&0===a.length||o.constructor===Object&&0===Object.keys(o).length||"boolean"==typeof o)&&(a=void 0),{route:n,params:a}}return{}}setDefaultHandler(e,t="GET"){this._defaultHandlerMap.set(t,O(e))}setCatchHandler(e){this._catchHandler=O(e)}registerRoute(e){g(e,"object",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),c(e,"match",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),g(e.handler,"object",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),c(e.handler,"handle",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route.handler"}),g(e.method,"string",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route.method"}),this._routes.has(e.method)||this._routes.set(e.method,[]),this._routes.get(e.method).push(e)}unregisterRoute(e){if(!this._routes.has(e.method))throw new i("unregister-route-but-not-found-with-method",{method:e.method});const t=this._routes.get(e.method).indexOf(e);if(!(t>-1))throw new i("unregister-route-route-not-registered");this._routes.get(e.method).splice(t,1)}}let F;function D(e,t,r){let s;if("string"==typeof e){const a=new URL(e,location.href);{if(!e.startsWith("/")&&!e.startsWith("http"))throw new i("invalid-string",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});const t=e.startsWith("http")?a.pathname:e,r="[*:?+]";new RegExp(`${r}`).exec(t)&&d.debug(`The '$capture' parameter contains an Express-style wildcard character (${r}). Strings are now always interpreted as exact matches; use a RegExp for partial or wildcard matches.`)}s=new K(({url:t})=>(t.pathname===a.pathname&&t.origin!==a.origin&&d.debug(`${e} only partially matches the cross-origin URL ${t.toString()}. This route will only handle cross-origin requests if they match the entire URL.`),t.href===a.href),t,r)}else if(e instanceof RegExp)s=new j(e,t,r);else if("function"==typeof e)s=new K(e,t,r);else{if(!(e instanceof K))throw new i("unsupported-route-type",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});s=e}return(F||(F=new W,F.addFetchListener(),F.addCacheListener()),F).registerRoute(s),s}class V extends K{constructor(e,t){super(({request:r})=>{const s=e.getURLsToCacheKeys();for(const a of function*(e,{ignoreURLParametersMatching:t=[/^utm_/,/^fbclid$/],directoryIndex:r="index.html",cleanURLs:s=!0,urlManipulation:a}={}){const n=new URL(e,location.href);n.hash="",yield n.href;const o=function(e,t=[]){for(const r of[...e.searchParams.keys()])t.some(e=>e.test(r))&&e.searchParams.delete(r);return e}(n,t);if(yield o.href,r&&o.pathname.endsWith("/")){const e=new URL(o.href);e.pathname+=r,yield e.href}if(s){const e=new URL(o.href);e.pathname+=".html",yield e.href}if(a){const e=a({url:n});for(const t of e)yield t.href}}(r.url,t)){const t=s.get(a);if(t){return{cacheKey:t,integrity:e.getIntegrityForCacheKey(t)}}}d.debug("Precaching did not find a match for "+m(r.url))},e.strategy)}}function H(){self.addEventListener("activate",e=>{const t=w();e.waitUntil((async(e,t="-precache-")=>{const r=(await self.caches.keys()).filter(r=>r.includes(t)&&r.includes(self.registration.scope)&&r!==e);return await Promise.all(r.map(e=>self.caches.delete(e))),r})(t).then(e=>{e.length>0&&d.log("The following out-of-date precaches were cleaned up automatically:",e)}))})}function B(e,t){!function(e){S().precache(e)}(e),function(e){const t=S();D(new V(t,e))}(t)}const z=[];for(let Te=0;Te<256;++Te)z.push((Te+256).toString(16).slice(1));let G;const J=new Uint8Array(16);const Y={randomUUID:"undefined"!=typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};function Q(e,t,r){if(Y.randomUUID&&!e)return Y.randomUUID();const s=(e=e||{}).random??e.rng?.()??function(){if(!G){if("undefined"==typeof crypto||!crypto.getRandomValues)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");G=crypto.getRandomValues.bind(crypto)}return G(J)}();if(s.length<16)throw new Error("Random bytes length must be >= 16");return s[6]=15&s[6]|64,s[8]=63&s[8]|128,function(e,t=0){return(z[e[t+0]]+z[e[t+1]]+z[e[t+2]]+z[e[t+3]]+"-"+z[e[t+4]]+z[e[t+5]]+"-"+z[e[t+6]]+z[e[t+7]]+"-"+z[e[t+8]]+z[e[t+9]]+"-"+z[e[t+10]]+z[e[t+11]]+z[e[t+12]]+z[e[t+13]]+z[e[t+14]]+z[e[t+15]]).toLowerCase()}(s)}var Z=Object.prototype.hasOwnProperty;function X(e,t){var r,s;if(e===t)return!0;if(e&&t&&(r=e.constructor)===t.constructor){if(r===Date)return e.getTime()===t.getTime();if(r===RegExp)return e.toString()===t.toString();if(r===Array){if((s=e.length)===t.length)for(;s--&&X(e[s],t[s]););return-1===s}if(!r||"object"==typeof e){for(r in s=0,e){if(Z.call(e,r)&&++s&&!Z.call(t,r))return!1;if(!(r in t)||!X(e[r],t[r]))return!1}return Object.keys(t).length===s}}return e!=e&&t!=t}const ee=new Error("request for lock canceled");var te=function(e,t,r,s){return new(r||(r=Promise))(function(a,n){function o(e){try{c(s.next(e))}catch(t){n(t)}}function i(e){try{c(s.throw(e))}catch(t){n(t)}}function c(e){var t;e.done?a(e.value):(t=e.value,t instanceof r?t:new r(function(e){e(t)})).then(o,i)}c((s=s.apply(e,t||[])).next())})};class re{constructor(e,t=ee){this._value=e,this._cancelError=t,this._queue=[],this._weightedWaiters=[]}acquire(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise((r,s)=>{const a={resolve:r,reject:s,weight:e,priority:t},n=se(this._queue,e=>t<=e.priority);-1===n&&e<=this._value?this._dispatchItem(a):this._queue.splice(n+1,0,a)})}runExclusive(e){return te(this,arguments,void 0,function*(e,t=1,r=0){const[s,a]=yield this.acquire(t,r);try{return yield e(s)}finally{a()}})}waitForUnlock(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,t)?Promise.resolve():new Promise(r=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),function(e,t){const r=se(e,e=>t.priority<=e.priority);e.splice(r+1,0,t)}(this._weightedWaiters[e-1],{resolve:r,priority:t})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach(e=>e.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const t=this._value;this._value-=e.weight,e.resolve([t,this._newReleaser(e.weight)])}_newReleaser(e){let t=!1;return()=>{t||(t=!0,this.release(e))}}_drainUnlockWaiters(){if(0===this._queue.length)for(let e=this._value;e>0;e--){const t=this._weightedWaiters[e-1];t&&(t.forEach(e=>e.resolve()),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let t=this._value;t>0;t--){const r=this._weightedWaiters[t-1];if(!r)continue;const s=r.findIndex(t=>t.priority<=e);(-1===s?r:r.splice(0,s)).forEach(e=>e.resolve())}}}_couldLockImmediately(e,t){return(0===this._queue.length||this._queue[0].priority<t)&&e<=this._value}}function se(e,t){for(let r=e.length-1;r>=0;r--)if(t(e[r]))return r;return-1}var ae=function(e,t,r,s){return new(r||(r=Promise))(function(a,n){function o(e){try{c(s.next(e))}catch(t){n(t)}}function i(e){try{c(s.throw(e))}catch(t){n(t)}}function c(e){var t;e.done?a(e.value):(t=e.value,t instanceof r?t:new r(function(e){e(t)})).then(o,i)}c((s=s.apply(e,t||[])).next())})};class ne{constructor(e){this._semaphore=new re(1,e)}acquire(){return ae(this,arguments,void 0,function*(e=0){const[,t]=yield this._semaphore.acquire(1,e);return t})}runExclusive(e,t=0){return this._semaphore.runExclusive(()=>e(),1,t)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}const oe=globalThis.browser?.runtime?.id?globalThis.browser:globalThis.chrome,ie=function(){const e={local:ce("local"),session:ce("session"),sync:ce("sync"),managed:ce("managed")},t=t=>{const r=e[t];if(null==r){const r=Object.keys(e).join(", ");throw Error(`Invalid area "${t}". Options: ${r}`)}return r},r=e=>{const r=e.indexOf(":"),s=e.substring(0,r),a=e.substring(r+1);if(null==a)throw Error(`Storage key should be in the form of "area:key", but received "${e}"`);return{driverArea:s,driverKey:a,driver:t(s)}},s=e=>e+"$",a=(e,t)=>{const r={...e};return Object.entries(t).forEach(([e,t])=>{null==t?delete r[e]:r[e]=t}),r},n=(e,t)=>e??t??null,o=e=>"object"!=typeof e||Array.isArray(e)?{}:e,i=async(e,t,r)=>{const s=await e.getItem(t);return n(s,r?.fallback??r?.defaultValue)},c=async(e,t)=>{const r=s(t),a=await e.getItem(r);return o(a)},l=async(e,t,r)=>{await e.setItem(t,r??null)},u=async(e,t,r)=>{const n=s(t),i=o(await e.getItem(n));await e.setItem(n,a(i,r))},h=async(e,t,r)=>{if(await e.removeItem(t),r?.removeMeta){const r=s(t);await e.removeItem(r)}},g=async(e,t,r)=>{const a=s(t);if(null==r)await e.removeItem(a);else{const t=o(await e.getItem(a));[r].flat().forEach(e=>delete t[e]),await e.setItem(a,t)}},m=(e,t,r)=>e.watch(t,r);return{getItem:async(e,t)=>{const{driver:s,driverKey:a}=r(e);return await i(s,a,t)},getItems:async t=>{const s=new Map,a=new Map,o=[];t.forEach(e=>{let t,n;"string"==typeof e?t=e:"getValue"in e?(t=e.key,n={fallback:e.fallback}):(t=e.key,n=e.options),o.push(t);const{driverArea:i,driverKey:c}=r(t),l=s.get(i)??[];s.set(i,l.concat(c)),a.set(t,n)});const i=new Map;return await Promise.all(Array.from(s.entries()).map(async([t,r])=>{(await e[t].getItems(r)).forEach(e=>{const r=`${t}:${e.key}`,s=a.get(r),o=n(e.value,s?.fallback??s?.defaultValue);i.set(r,o)})})),o.map(e=>({key:e,value:i.get(e)}))},getMeta:async e=>{const{driver:t,driverKey:s}=r(e);return await c(t,s)},getMetas:async e=>{const t=e.map(e=>{const t="string"==typeof e?e:e.key,{driverArea:a,driverKey:n}=r(t);return{key:t,driverArea:a,driverKey:n,driverMetaKey:s(n)}}),a=t.reduce((e,t)=>(e[t.driverArea]??=[],e[t.driverArea].push(t),e),{}),n={};return await Promise.all(Object.entries(a).map(async([e,t])=>{const r=await oe.storage[e].get(t.map(e=>e.driverMetaKey));t.forEach(e=>{n[e.key]=r[e.driverMetaKey]??{}})})),t.map(e=>({key:e.key,meta:n[e.key]}))},setItem:async(e,t)=>{const{driver:s,driverKey:a}=r(e);await l(s,a,t)},setItems:async e=>{const s={};e.forEach(e=>{const{driverArea:t,driverKey:a}=r("key"in e?e.key:e.item.key);s[t]??=[],s[t].push({key:a,value:e.value})}),await Promise.all(Object.entries(s).map(async([e,r])=>{const s=t(e);await s.setItems(r)}))},setMeta:async(e,t)=>{const{driver:s,driverKey:a}=r(e);await u(s,a,t)},setMetas:async e=>{const n={};e.forEach(e=>{const{driverArea:t,driverKey:s}=r("key"in e?e.key:e.item.key);n[t]??=[],n[t].push({key:s,properties:e.meta})}),await Promise.all(Object.entries(n).map(async([e,r])=>{const n=t(e),i=r.map(({key:e})=>s(e)),c=await n.getItems(i),l=Object.fromEntries(c.map(({key:e,value:t})=>[e,o(t)])),u=r.map(({key:e,properties:t})=>{const r=s(e);return{key:r,value:a(l[r]??{},t)}});await n.setItems(u)}))},removeItem:async(e,t)=>{const{driver:s,driverKey:a}=r(e);await h(s,a,t)},removeItems:async e=>{const a={};e.forEach(e=>{let t,n;"string"==typeof e?t=e:"getValue"in e?t=e.key:"item"in e?(t=e.item.key,n=e.options):(t=e.key,n=e.options);const{driverArea:o,driverKey:i}=r(t);a[o]??=[],a[o].push(i),n?.removeMeta&&a[o].push(s(i))}),await Promise.all(Object.entries(a).map(async([e,r])=>{const s=t(e);await s.removeItems(r)}))},clear:async e=>{const r=t(e);await r.clear()},removeMeta:async(e,t)=>{const{driver:s,driverKey:a}=r(e);await g(s,a,t)},snapshot:async(e,r)=>{const a=t(e),n=await a.snapshot();return r?.excludeKeys?.forEach(e=>{delete n[e],delete n[s(e)]}),n},restoreSnapshot:async(e,r)=>{const s=t(e);await s.restoreSnapshot(r)},watch:(e,t)=>{const{driver:s,driverKey:a}=r(e);return m(s,a,t)},unwatch(){Object.values(e).forEach(e=>{e.unwatch()})},defineItem:(e,t)=>{const{driver:a,driverKey:n}=r(e),{version:o=1,migrations:d={},onMigrationComplete:p,debug:f=!1}=t??{};if(o<1)throw Error("Storage item version cannot be less than 1. Initial versions should be set to 1, not 0.");const w=async()=>{const t=s(n),[{value:r},{value:i}]=await a.getItems([n,t]);if(null==r)return;const c=i?.v??1;if(c>o)throw Error(`Version downgrade detected (v${c} -> v${o}) for "${e}"`);if(c===o)return;const l=Array.from({length:o-c},(e,t)=>c+t+1);let u=r;for(const s of l)try{u=await(d?.[s]?.(u))??u}catch(h){throw new le(e,s,{cause:h})}await a.setItems([{key:n,value:u},{key:t,value:{...i,v:o}}]),p?.(u,o)},y=null==t?.migrations?Promise.resolve():w().catch(e=>{}),A=new ne,v=()=>t?.fallback??t?.defaultValue??null,x=()=>A.runExclusive(async()=>{const e=await a.getItem(n);if(null!=e||null==t?.init)return e;const r=await t.init();return await a.setItem(n,r),r});return y.then(x),{key:e,get defaultValue(){return v()},get fallback(){return v()},getValue:async()=>(await y,t?.init?await x():await i(a,n,t)),getMeta:async()=>(await y,await c(a,n)),setValue:async e=>(await y,await l(a,n,e)),setMeta:async e=>(await y,await u(a,n,e)),removeValue:async e=>(await y,await h(a,n,e)),removeMeta:async e=>(await y,await g(a,n,e)),watch:e=>m(a,n,(t,r)=>e(t??v(),r??v())),migrate:w}}}}();function ce(e){const t=()=>{if(null==oe.runtime)throw Error(["'wxt/storage' must be loaded in a web extension environment","\n - If thrown during a build, see https://github.com/wxt-dev/wxt/issues/371"," - If thrown during tests, mock 'wxt/browser' correctly. See https://wxt.dev/guide/go-further/testing.html\n"].join("\n"));if(null==oe.storage)throw Error("You must add the 'storage' permission to your manifest to use 'wxt/storage'");const t=oe.storage[e];if(null==t)throw Error(`"browser.storage.${e}" is undefined`);return t},r=new Set;return{getItem:async e=>(await t().get(e))[e],getItems:async e=>{const r=await t().get(e);return e.map(e=>({key:e,value:r[e]??null}))},setItem:async(e,r)=>{null==r?await t().remove(e):await t().set({[e]:r})},setItems:async e=>{const r=e.reduce((e,{key:t,value:r})=>(e[t]=r,e),{});await t().set(r)},removeItem:async e=>{await t().remove(e)},removeItems:async e=>{await t().remove(e)},clear:async()=>{await t().clear()},snapshot:async()=>await t().get(),restoreSnapshot:async e=>{await t().set(e)},watch(e,s){const a=t=>{const r=t[e];null!=r&&(X(r.newValue,r.oldValue)||s(r.newValue??null,r.oldValue??null))};return t().onChanged.addListener(a),r.add(a),()=>{t().onChanged.removeListener(a),r.delete(a)}},unwatch(){r.forEach(e=>{t().onChanged.removeListener(e)}),r.clear()}}}class le extends Error{constructor(e,t,r){super(`v${t} migration failed for "${e}"`,r),this.key=e,this.version=t}}async function ue(e,t){await ie.setItem(`local:${e}`,t)}async function he(e){const t=await ie.getItem(`local:${e}`);return"boolean"==typeof t?t:t||null}async function ge(){const e=await he("gaClientId");let t;return e?.ga_client_id?t=e.ga_client_id:(t=Q(),await ue("gaClientId",{ga_client_id:t})),t}const me=(()=>{async function e(e,r={}){const s=await he("generalSettings");if(s?.disable_analytics)return;t({client_id:await ge(),events:[{name:e,params:{...r,session_id:await async function(){const e=await he("analyticsSession"),t=18e5;if(e?.session_id&&e?.timestamp){const r=new Date(e.timestamp).getTime();if(Date.now()-r<t)return await ue("analyticsSession",{session_id:e.session_id,timestamp:(new Date).toISOString()}),e.session_id}const r=Q();return await ue("analyticsSession",{session_id:r,timestamp:(new Date).toISOString()}),r}()}}]})}function t(e){}return{pageView:async function(e,r){const s=await he("generalSettings");if(s?.disable_analytics)return;t({client_id:await ge(),events:[{name:"page_view",params:{page_title:e,page_location:r}}]})},event:e,error:async function(t,r){const s=await he("generalSettings");s?.disable_analytics||await e("error",{error_message:t,error_source:r})}}})(),de=null==(pe=()=>{"undefined"!=typeof self&&"__WB_MANIFEST"in self&&B(self.__WB_MANIFEST),a.action.onClicked.addListener(()=>{a.tabs.create({url:a.runtime.getURL("/newtab.html")}),me.event("IconClicked")}),a.runtime.onInstalled.addListener(async e=>{if("install"===e.reason){await ue("showWelcomeModal",!0);const e=a.runtime.getManifest();me.event("Installed",{version:e.version,offlineSupport:!0}),await fe()}else if("update"===e.reason){const t=a.runtime.getManifest(),r=e.previousVersion||"unknown";me.event("Updated",{version:t.version,previousVersion:r,offlineSupport:!0}),await H(),await fe()}}),a.runtime.onStartup.addListener(async()=>{me.event("Startup")}),H()})||"function"==typeof pe?{main:pe}:pe;var pe;async function fe(){try{const e=await caches.open("critical-resources-v1"),t=["/newtab.html"].filter(Boolean);t.length>0&&await e.addAll(t)}catch(e){}}var we=class{constructor(e){if("<all_urls>"===e)this.isAllUrls=!0,this.protocolMatches=[...we.PROTOCOLS],this.hostnameMatch="*",this.pathnameMatch="*";else{const t=/(.*):\/\/(.*?)(\/.*)/.exec(e);if(null==t)throw new Ae(e,"Incorrect format");const[r,s,a,n]=t;!function(e,t){if(!ye.PROTOCOLS.includes(t)&&"*"!==t)throw new Ae(e,`${t} not a valid protocol (${ye.PROTOCOLS.join(", ")})`)}(e,s),function(e,t){if(t.includes(":"))throw new Ae(e,"Hostname cannot include a port");if(t.includes("*")&&t.length>1&&!t.startsWith("*."))throw new Ae(e,"If using a wildcard (*), it must go at the start of the hostname")}(e,a),this.protocolMatches="*"===s?["http","https"]:[s],this.hostnameMatch=a,this.pathnameMatch=n}}includes(e){if(this.isAllUrls)return!0;const t="string"==typeof e?new URL(e):e instanceof Location?new URL(e.href):e;return!!this.protocolMatches.find(e=>"http"===e?this.isHttpMatch(t):"https"===e?this.isHttpsMatch(t):"file"===e?this.isFileMatch(t):"ftp"===e?this.isFtpMatch(t):"urn"===e?this.isUrnMatch(t):void 0)}isHttpMatch(e){return"http:"===e.protocol&&this.isHostPathMatch(e)}isHttpsMatch(e){return"https:"===e.protocol&&this.isHostPathMatch(e)}isHostPathMatch(e){if(!this.hostnameMatch||!this.pathnameMatch)return!1;const t=[this.convertPatternToRegex(this.hostnameMatch),this.convertPatternToRegex(this.hostnameMatch.replace(/^\*\./,""))],r=this.convertPatternToRegex(this.pathnameMatch);return!!t.find(t=>t.test(e.hostname))&&r.test(e.pathname)}isFileMatch(e){throw Error("Not implemented: file:// pattern matching. Open a PR to add support")}isFtpMatch(e){throw Error("Not implemented: ftp:// pattern matching. Open a PR to add support")}isUrnMatch(e){throw Error("Not implemented: urn:// pattern matching. Open a PR to add support")}convertPatternToRegex(e){const t=this.escapeForRegex(e).replace(/\\\*/g,".*");return RegExp(`^${t}$`)}escapeForRegex(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}},ye=we;ye.PROTOCOLS=["http","https","file","ftp","urn"];var Ae=class extends Error{constructor(e,t){super(`Invalid match pattern "${e}": ${t}`)}};function ve(e,...t){if("string"==typeof t[0]){e(`[wxt] ${t.shift()}`,...t)}else e("[wxt]",...t)}const xe=(...e)=>ve(console.debug,...e),be=(...e)=>ve(console.log,...e),_e=(...e)=>ve(console.warn,...e),ke=(...e)=>ve(console.error,...e);let Re,$e;function Ce(e){2==a.runtime.getManifest().manifest_version?async function(){throw Error("TODO: reloadContentScriptMv2")}():async function({registration:e,contentScript:t}){"runtime"===e?await async function(e){be("Reloading content script:",e);const t=await a.scripting.getRegisteredContentScripts();xe("Existing scripts:",t);const r=t.filter(t=>{const r=e.js?.find(e=>t.js?.includes(e)),s=e.css?.find(e=>t.css?.includes(e));return r||s});if(0===r.length)return void be("Content script is not registered yet, nothing to reload",e);await a.scripting.updateContentScripts(r),await Ee(e)}(t):await async function(e){const t=`wxt:${e.js[0]}`;be("Reloading content script:",e);const r=await a.scripting.getRegisteredContentScripts();xe("Existing scripts:",r);const s=r.find(e=>e.id===t);s?(xe("Updating content script",s),await a.scripting.updateContentScripts([{...e,id:t,css:e.css??[]}])):(xe("Registering new content script..."),await a.scripting.registerContentScripts([{...e,id:t,css:e.css??[]}]));await Ee(e)}(t)}(e)}async function Ee(e){const t=await a.tabs.query({}),r=e.matches.map(e=>new ye(e)),s=t.filter(e=>{const t=e.url;return!!t&&!!r.find(e=>e.includes(t))});await Promise.all(s.map(async e=>{try{await a.tabs.reload(e.id)}catch(t){_e("Failed to reload tab:",t)}}))}try{const e=function(){if(null==Re){const e="ws://localhost:3000";xe("Connecting to dev server @",e),Re=new WebSocket(e,"vite-hmr"),Re.addWxtEventListener=Re.addEventListener.bind(Re),Re.sendCustom=(e,t)=>Re?.send(JSON.stringify({type:"custom",event:e,payload:t})),Re.addEventListener("open",()=>{xe("Connected to dev server")}),Re.addEventListener("close",()=>{xe("Disconnected from dev server")}),Re.addEventListener("error",e=>{ke("Failed to connect to dev server",e)}),Re.addEventListener("message",e=>{try{const t=JSON.parse(e.data);"custom"===t.type&&Re?.dispatchEvent(new CustomEvent(t.event,{detail:t.data}))}catch(t){ke("Failed to handle message",t)}})}return Re}();e.addWxtEventListener("wxt:reload-extension",()=>{a.runtime.reload()}),e.addWxtEventListener("wxt:reload-content-script",e=>{Ce(e.detail)}),e.addEventListener("open",()=>e.sendCustom("wxt:background-initialized")),setInterval(async()=>{await a.runtime.getPlatformInfo()},5e3)}catch(Ne){ke("Failed to setup web socket connection with dev server",Ne)}a.commands.onCommand.addListener(e=>{"wxt:reload-extension"===e&&a.runtime.reload()});try{$e=de.main()}catch(Ne){throw ke("The background crashed on startup!"),Ne}return $e}();
